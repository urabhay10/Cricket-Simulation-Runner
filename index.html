<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NextGen Cricket Simulator</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;600;800&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        .font-mono { font-family: 'JetBrains Mono', monospace; }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        
        .suggestion-active {
            background-color: #334155;
            border-left: 4px solid #10b981;
        }

        .ball-pop {
            animation: pop 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes pop {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const PlayerInput = ({ value, onChange, placeholder }) => {
            const [suggestions, setSuggestions] = useState([]);
            const [show, setShow] = useState(false);
            const [selectedIndex, setSelectedIndex] = useState(-1);
            const listRef = useRef(null);

            const handleInputChange = (e) => {
                const text = e.target.value;
                onChange(text);
                if (text.length >= 1) {
                    fetch(`https://hewhocodes247-cricket-transformer-api.hf.space/players/search?q=${text}`)
                        .then(res => res.json())
                        .then(data => {
                            setSuggestions(data);
                            setShow(true);
                            setSelectedIndex(-1);
                        })
                        .catch(err => console.error(err));
                } else {
                    setSuggestions([]);
                    setShow(false);
                }
            };

            const handleSelect = (player) => {
                if (!player) return;
                onChange(player.name);
                setShow(false);
                setSuggestions([]);
                setSelectedIndex(-1);
            };

            const handleKeyDown = (e) => {
                if (!show || suggestions.length === 0) return;
                if (e.key === "ArrowDown") {
                    e.preventDefault();
                    setSelectedIndex(prev => (prev < suggestions.length - 1 ? prev + 1 : prev));
                } else if (e.key === "ArrowUp") {
                    e.preventDefault();
                    setSelectedIndex(prev => (prev > 0 ? prev - 1 : prev));
                } else if (e.key === "Enter") {
                    e.preventDefault();
                    if (selectedIndex >= 0 && suggestions[selectedIndex]) {
                        handleSelect(suggestions[selectedIndex]);
                    }
                } else if (e.key === "Escape") {
                    setShow(false);
                }
            };

            return (
                <div className="relative">
                    <input
                        type="text"
                        className="w-full bg-slate-800 border border-slate-700 rounded p-2 text-sm focus:border-emerald-500 focus:outline-none transition-colors"
                        placeholder={placeholder}
                        value={value}
                        onChange={handleInputChange}
                        onKeyDown={handleKeyDown}
                        onBlur={() => setTimeout(() => setShow(false), 200)}
                    />
                    {show && suggestions.length > 0 && (
                        <ul ref={listRef} className="absolute z-10 w-full bg-slate-800 border border-slate-700 mt-1 rounded max-h-48 overflow-y-auto shadow-xl scrollbar-hide">
                            {suggestions.map((s, i) => (
                                <li key={i} 
                                    className={`p-2 hover:bg-slate-700 cursor-pointer text-sm border-b border-slate-700/50 flex justify-between transition-colors ${i === selectedIndex ? 'suggestion-active bg-slate-700' : ''}`}
                                    onMouseEnter={() => setSelectedIndex(i)}
                                    onClick={() => handleSelect(s)}>
                                    <span className="text-white">{s.name}</span>
                                    <span className={`text-xs px-2 py-0.5 rounded h-fit ${s.role === 'Bowler' ? 'bg-rose-900/50 text-rose-300' : 'bg-emerald-900/50 text-emerald-300'}`}>
                                        {s.role}
                                    </span>
                                </li>
                            ))}
                        </ul>
                    )}
                </div>
            );
        };

        const ScoreCard = ({ detail, live }) => {
            if (!detail) return null;
            // Destructuring with safety defaults to prevent crashes
            const { striker, non_striker, bowler, total_runs = 0, wickets = 0, bat_team = "", target, over = 0, ball = 0 } = detail || {};
            
            const ballsDone = over * 6 + ball;
            const crr = ballsDone > 0 ? ((total_runs / ballsDone) * 6).toFixed(2) : "0.00";
            let rrr = null;
            if (target) {
                const ballsRem = 120 - ballsDone;
                const runsRem = target - total_runs;
                rrr = ballsRem > 0 ? ((runsRem / ballsRem) * 6).toFixed(2) : "-";
            }

            return (
                <div className="bg-slate-800 rounded-xl p-6 shadow-2xl border border-slate-700 mb-6 relative overflow-hidden">
                    {live && <div className="absolute top-4 right-4 flex items-center gap-2">
                        <span className="animate-pulse w-3 h-3 bg-red-500 rounded-full"></span>
                        <span className="text-xs font-bold text-red-500 uppercase tracking-widest">Live</span>
                    </div>}
                    <div className="text-center mb-8">
                        <div className="text-lg text-slate-400 uppercase tracking-widest font-semibold mb-2">{bat_team}</div>
                        <div className="text-6xl font-black font-mono tracking-tighter text-white">{total_runs}<span className="text-slate-500">/</span>{wickets}</div>
                        <div className="text-emerald-400 font-mono mt-2 text-xl">Overs: {over}.{ball}</div>
                        <div className="flex justify-center gap-6 mt-4 text-xs font-mono text-slate-400">
                            <div>CRR: {crr}</div>
                            {target && <div>Target: {target}</div>}
                            {target && <div>RRR: {rrr}</div>}
                        </div>
                    </div>
                    <div className="grid grid-cols-2 gap-4">
                        <div className="bg-slate-900/50 p-4 rounded-lg border border-slate-700/50">
                            <div className="text-xs text-slate-500 uppercase mb-3 flex items-center gap-2 font-bold">üèè Batting</div>
                            {striker && (
                                <div className="flex justify-between items-center mb-2">
                                    <span className="font-bold text-emerald-300 truncate pr-2">{striker.name} *</span>
                                    <span className="font-mono text-slate-300 whitespace-nowrap">{striker.runs}<span className="text-slate-500 text-xs">({striker.balls})</span></span>
                                </div>
                            )}
                            {non_striker && (
                                <div className="flex justify-between items-center">
                                    <span className="text-slate-400 truncate pr-2">{non_striker.name}</span>
                                    <span className="font-mono text-slate-400 whitespace-nowrap">{non_striker.runs}<span className="text-slate-500 text-xs">({non_striker.balls})</span></span>
                                </div>
                            )}
                        </div>
                        <div className="bg-slate-900/50 p-4 rounded-lg border border-slate-700/50">
                            <div className="text-xs text-slate-500 uppercase mb-3 flex items-center gap-2 font-bold">ü•é Bowling</div>
                            {bowler && (
                                <div>
                                    <div className="flex justify-between items-center mb-1"><span className="font-bold text-rose-300 truncate pr-2">{bowler.name}</span></div>
                                    <div className="flex justify-between text-xs font-mono text-slate-400">
                                        <span>{bowler.wickets}-{bowler.runs_given}</span>
                                        <span>({bowler.overs}.{ball})</span>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        const Commentary = ({ events }) => {
            const endRef = useRef(null);
            useEffect(() => endRef.current?.scrollIntoView({ behavior: "smooth" }), [events]);

            const groupedOvers = [];
            events.forEach(e => {
                // Safeguard against malformed events
                if (!e || typeof e.over === 'undefined') return;
                
                const key = `${e.innings}-${e.over}`;
                let over = groupedOvers.find(o => o.key === key);
                if (!over) {
                    over = { key: key, team: e.bat_team, balls: [], runs: e.total_runs, wickets: e.wickets };
                    groupedOvers.push(over);
                }
                over.balls.push(e.is_wicket ? 'W' : e.runs_scored);
                over.runs = e.total_runs;
                over.wickets = e.wickets;
            });

            return (
                <div className="bg-slate-900 rounded-xl p-4 h-64 overflow-y-auto border border-slate-800 font-mono text-sm scrollbar-hide">
                    {events.length === 0 && <div className="text-center text-slate-600 italic mt-20">Waiting...</div>}
                    {groupedOvers.map((over) => (
                        <div key={over.key} className="mb-2 p-3 bg-slate-800/50 rounded-lg border border-slate-700/50 flex items-center justify-between ball-pop">
                            <div className="flex items-center gap-4">
                                <span className="text-slate-500 font-bold w-16">Over {parseInt(over.key.split('-')[1]) + 1}</span>
                                <div className="flex gap-2">
                                    {over.balls.map((b, j) => (
                                        <span key={j} className={`w-6 h-6 flex items-center justify-center rounded-full text-xs font-bold ${b === 'W' ? 'bg-rose-500 text-white' : b === 6 || b === 4 ? 'bg-emerald-500 text-slate-900' : 'bg-slate-700 text-slate-300'}`}>
                                            {b}
                                        </span>
                                    ))}
                                </div>
                            </div>
                            <span className="text-slate-400 text-xs font-bold">{over.team} {over.runs}/{over.wickets}</span>
                        </div>
                    ))}
                    <div ref={endRef} />
                </div>
            );
        };

        const MatchScorecard = ({ teamName, data, matchNo }) => {
            // CRITICAL FIX: If data or batting is missing, render nothing instead of crashing the app
            if (!data || !data.batting) {
                console.warn(`Missing batting data for ${teamName} in match ${matchNo}`, data);
                return null;
            }

            return (
                <div className="bg-slate-900 rounded-xl border border-slate-800 overflow-hidden mb-6">
                    <div className="bg-slate-800 px-4 py-2 border-b border-slate-700 flex justify-between items-center">
                        <span className="font-black text-emerald-400 uppercase tracking-wider">{teamName}</span>
                        <span className="font-mono font-bold text-white">{data.score}</span>
                    </div>
                    <div className="p-4 overflow-x-auto scrollbar-hide">
                        <table className="w-full text-[10px] font-mono mb-4">
                            <thead className="text-slate-500 border-b border-slate-800 text-left">
                                <tr><th className="py-1">Batter</th><th className="text-right">R</th><th className="text-right">B</th></tr>
                            </thead>
                            <tbody>
                                {data.batting.filter(b => b.balls > 0 || b.out).map((b, i) => (
                                    <tr key={i} className="border-b border-slate-800/50">
                                        <td className={`py-1 ${b.out ? 'text-slate-500' : 'text-emerald-300'}`}>{b.name}{!b.out ? '*' : ''}</td>
                                        <td className="text-right">{b.runs}</td>
                                        <td className="text-right">{b.balls}</td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [stage, setStage] = useState('setup');
            const [numMatches, setNumMatches] = useState(1);
            const [team1, setTeam1] = useState({ name: "India", players: Array(11).fill("") });
            const [team2, setTeam2] = useState({ name: "Australia", players: Array(11).fill("") });
            const [matchDetail, setMatchDetail] = useState(null);
            const [ballEvents, setBallEvents] = useState([]);
            const [history, setHistory] = useState([]);
            const [seriesComplete, setSeriesComplete] = useState(null);

            const fillDefaults = () => {
                setTeam1({ name: "India", players: ["RG Sharma", "V Kohli", "RR Pant", "SA Yadav", "S Dube", "HH Pandya", "RA Jadeja", "AR Patel", "Kuldeep Yadav", "JJ Bumrah", "Arshdeep Singh"] });
                setTeam2({ name: "Australia", players: ["DA Warner", "TM Head", "MR Marsh", "GJ Maxwell", "MP Stoinis", "TH David", "MS Wade", "PJ Cummins", "MA Starc", "A Zampa", "JR Hazlewood"] });
            };

            const updatePlayer = (tId, idx, v) => {
                if (tId === 1) { const n = [...team1.players]; n[idx] = v; setTeam1({...team1, players: n}); }
                else { const n = [...team2.players]; n[idx] = v; setTeam2({...team2, players: n}); }
            };

            const startSimulation = async () => {
                setStage('live');
                setBallEvents([]);
                setMatchDetail(null);
                setHistory([]);
                setSeriesComplete(null);
                
                console.log("Starting simulation...");

                try {
                    const response = await fetch('https://hewhocodes247-cricket-transformer-api.hf.space/simulate_series_stream', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            team1_name: team1.name,
                            team1_players: team1.players,
                            team2_name: team2.name,
                            team2_players: team2.players,
                            num_matches: numMatches
                        })
                    });

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = "";

                    const processLine = (line) => {
                        if (!line.trim()) return;
                        try {
                            const data = JSON.parse(line);
                            
                            // Debug logging for events
                            if (data.type === 'series_complete') {
                                console.log("Received Series Complete:", data);
                            } else if (data.type === 'match_update') {
                                console.log("Received Match Update:", data);
                            }

                            if (data.type === 'ball') {
                                setMatchDetail(data.detail);
                                setBallEvents(prev => [...prev, { ...data.detail, innings: data.innings }]);
                            } else if (data.type === 'match_update') {
                                setHistory(prev => [data, ...prev]);
                            } else if (data.type === 'series_complete') {
                                setSeriesComplete(data);
                            }
                        } catch (e) {
                            console.error("Error parsing JSON line:", line, e);
                        }
                    };

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            console.log("Stream reader done.");
                            break;
                        }
                        
                        const chunk = decoder.decode(value, { stream: true });
                        buffer += chunk;
                        
                        const lines = buffer.split('\n');
                        buffer = lines.pop(); // Keep incomplete line in buffer
                        
                        lines.forEach(processLine);
                    }

                    // Flush any remaining data in the buffer after stream ends
                    if (buffer.trim()) {
                        console.log("Flushing final buffer:", buffer);
                        processLine(buffer);
                    }

                } catch (err) {
                    console.error("Simulation Error:", err);
                    alert("Simulation failure. Check console for details.");
                    setStage('setup');
                }
            };
            
            if (stage === 'setup') return (
                <div className="min-h-screen p-8 max-w-6xl mx-auto">
                    <header className="mb-12 text-center">
                        <h1 className="text-5xl font-black bg-gradient-to-r from-emerald-400 to-cyan-500 bg-clip-text text-transparent tracking-tight">CRICKET SERIES SIMULATOR</h1>
                    </header>
                    <div className="grid md:grid-cols-2 gap-12">
                        <div className="space-y-4">
                            <input value={team1.name} onChange={e => setTeam1({...team1, name: e.target.value})} className="w-full bg-transparent text-2xl font-bold border-b-2 border-slate-700 focus:border-emerald-500 outline-none pb-2 text-emerald-400" placeholder="Team 1" />
                            {team1.players.map((p, i) => <PlayerInput key={i} value={p} onChange={v => updatePlayer(1, i, v)} placeholder={`Player ${i+1}`} />)}
                        </div>
                        <div className="space-y-4 text-right">
                            <input value={team2.name} onChange={e => setTeam2({...team2, name: e.target.value})} className="w-full bg-transparent text-2xl font-bold border-b-2 border-slate-700 focus:border-rose-500 outline-none pb-2 text-rose-400 text-right" placeholder="Team 2" />
                            {team2.players.map((p, i) => <PlayerInput key={i} value={p} onChange={v => updatePlayer(2, i, v)} placeholder={`Player ${i+1}`} />)}
                        </div>
                    </div>
                    <div className="mt-16 flex flex-col items-center gap-6">
                        <div className="flex items-center gap-4 bg-slate-800 p-3 rounded-xl border border-slate-700">
                            <span className="text-slate-400 font-bold">Games:</span>
                            <input type="number" value={numMatches} onChange={e => setNumMatches(Math.max(1, parseInt(e.target.value) || 1))} className="bg-slate-900 w-16 p-1 text-center font-bold text-emerald-400 border border-slate-700 rounded" />
                        </div>
                        <div className="flex gap-4">
                            <button onClick={fillDefaults} className="px-8 py-3 rounded-xl text-slate-400 border border-slate-700 font-bold hover:bg-slate-800 transition">Quick Fill</button>
                            <button onClick={startSimulation} className="px-12 py-3 rounded-xl bg-emerald-500 text-slate-900 font-black hover:scale-105 transition">START SERIES</button>
                        </div>
                    </div>
                </div>
            );

            return (
                <div className="min-h-screen p-6 bg-slate-950 flex flex-col items-center">
                    <div className="w-full max-w-5xl grid md:grid-cols-3 gap-6">
                        <div className="md:col-span-2 space-y-6">
                            <div className="flex justify-between items-center">
                                <button onClick={() => setStage('setup')} className="text-sm font-bold text-slate-500 hover:text-white">‚Üê RESET</button>
                                {seriesComplete && <div className="text-emerald-400 font-black animate-pulse uppercase tracking-widest text-xs">Series Concluded</div>}
                            </div>
                            
                            {/* Loading State: Prevents "Blue Screen" if matchDetail is null */}
                            {!matchDetail && !seriesComplete && (
                                <div className="flex flex-col items-center justify-center h-64 text-slate-500 animate-pulse bg-slate-900/50 rounded-xl border border-slate-800 border-dashed">
                                    <div className="text-4xl mb-4">üèè</div>
                                    <div className="font-mono text-sm uppercase tracking-widest">Initializing Pitch...</div>
                                </div>
                            )}

                            <ScoreCard detail={matchDetail} live={!seriesComplete} />
                            <Commentary events={ballEvents} />
                        </div>

                        <div className="space-y-6 max-h-screen overflow-y-auto scrollbar-hide">
                            <h2 className="text-lg font-black text-slate-400 uppercase tracking-widest border-b border-slate-800 pb-2">Series Results</h2>
                            {history.length === 0 && <div className="text-slate-600 italic text-sm">Waiting for first match...</div>}
                            {history.map((m, idx) => (
                                <div key={idx} className="space-y-4">
                                    <div className="p-3 bg-slate-900 border border-emerald-500/20 rounded-lg text-xs">
                                        <div className="font-bold text-emerald-400 mb-1">Match {history.length - idx}: {m.winner}</div>
                                        <div className="text-slate-500">Won by {m.margin}</div>
                                    </div>
                                    {/* Added safety chain ?. checks */}
                                    <div className="grid grid-cols-2 gap-2">
                                        {m.scorecard && Object.entries(m.scorecard).map(([name, data]) => (
                                            <MatchScorecard key={name} teamName={name} data={data} matchNo={m.match_no} />
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                    {seriesComplete && (
                        <div className="w-full max-w-5xl mt-12 bg-emerald-900/10 border border-emerald-500/20 p-8 rounded-3xl text-center">
                            <h3 className="text-xs font-black text-emerald-500 uppercase tracking-widest mb-4">Series Summary</h3>
                            <div className="text-3xl font-black text-white">
                                {/* FIX: Ensure we render string/text, not an Object */}
                                {typeof seriesComplete.summary === 'object' && seriesComplete.summary.scoreline 
                                    ? seriesComplete.summary.scoreline 
                                    : (typeof seriesComplete.summary === 'string' ? seriesComplete.summary : JSON.stringify(seriesComplete.summary))}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
        lucide.createIcons();
    </script>
</body>
</html>